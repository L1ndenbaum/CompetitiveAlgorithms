// 动态规划

/*
一、动态规划的概念
动态规划可以处理具有以下两个特征的问题；重叠子问题、最优子结构
(1)重叠子问题：
子问题是原大问题的小版本，它们的计算步骤完全一致。计算大问题时需要多次重复计算小问题。
一个子问题的多次计算耗费大量时间，用DP处理，使每个子问题只需要计算一次，即：
先分析得到最优子结构，之后用递推或者带记忆化搜索的递归进行编程。
(2)最优子结构：
大问题的最优解包含小问题的最优解，可以通过小问题的最优解推导出大问题的最优解。

有些问题用贪心算法不能获得最优解，但往往可以用DP获得最优解。
*/

/*
二、动态规划基础
动态规划有四大基本问题：状态设计、状态转移方程、DP代码实现、滚动数组
以0/1背包为例进行说明
例：背包1
小明有一个容量为C的背包。他去商场购物，商场一共有N个物品，第i件物品的体积为C[i]，价值为w[i]。
小明想知道在购买的物品总体积不超过C的情况下，他能获得的最大价值是多少。
输入：第一行两个正整数N，C 分别表示商场物品数量和小明的背包容量。
     第2~N+1行每行两个正整数c,w，分别表示物品的体积和价值
     1<=N<=100,1<=C<=1000,1<=w[i],C[i]<=1000
输出：输出一行整数，表示小明能获得的最大价值

1.状态设计：
定义二维数组dp[][]，大小为N*C。
dp[i][j]表示把前i个(第1个到第i个)物品装入容量为j的背包中获得的最大价值。
把每个dp[i][j]都看成一个背包：背包的容量为j，装第1~第i个物品。
最后得到的dp[N][C]即为答案：将N个物品装进容量为C的背包的最大价值。
注：dp[][]是一种状态。

2.状态转移方程
假设现在已经递推到dp[i][j]，分以下两种情况：
(1)第i个物品的体积比容量j还大，不能被装进容量为j的背包。
   直接继承前i-1个物品装进容量为j的背包的情况即可，即dp[i][j]=dp[i-1][j]。
(2)第i个物品的体积比容量j小，能装进背包，那么又可以分为两种情况：装或者不装第i个物品
    [1]如果装第i个物品，从前i-1个物品的情况推测而来，前i-1个物品是dp[i-1][j]。
      将第i个物品装进背包后，背包容量减少c[i]，价值增加w[i]，所以有dp[i][j]=dp[i-1][j-c[i]]+w[i]
    [2]如果不装第i个物品，有dp[i][j]=dp[i-1][j]。
取[1]和[2]的最大值，状态转移方程如下：
dp[i][j]=max(dp[i-1][j-c[i]]+w[i],dp[i-1][j])
总结上述分析，0/1背包为题的重叠子问题是dp[i][j]，最优子结构是dp[i][j]的状态转移方程。
复杂度分析：算法需要计算二维矩阵dp[N][C]，矩阵大小O(NC)，每一次计算时间O(1)，即总时间复杂度O(NC)，空间复杂度O(NC)
*/
/*
0/1背包问题代码实现：
DP的代码实现有两种方式：递推或记忆化
处理DP中的大问题和小问题，有两种思路：
一种是自上而下(Top-Down)，即先处理大问题后处理小问题；
另一种是自下而上(Bottom-Up)，即先处理小问题后处理大问题。
实现DP时，自上而下用带记忆化搜索的递归代码，自下而上用递推代码。
两种方法拥有相同的复杂度，每个问题计算且只计算一遍。
*/

// 递推
/*
这种自下而上的方法先解决小问题，在递推到大问题，通常通过填写多维表格完成，
编程时用若干for循环语句填表，根据表中的结果，逐步计算出大问题的解决方案。
*/
#include <iostream>
using namespace std;
const int N = 3010;
int w[N], c[N]; // 物品的价值和体积
int dp[N][N];
int Backpack_recursion(int n, int C)
{
  for (int i = 1; i <= n; i++)
  {
    for (int j = 0; j <= C; j++)
    {
      if (c[i] > j)
        dp[i][j] = dp[i - 1][j]; // 第i个物品的体积比背包容量大，背包装不了。
      else
        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]);
    }
  }
  return dp[n][C];
}
// 递归+记忆化
/*
先考虑大问题，再缩小到小问题，递归直接体现了这种思路。
为了避免递归时重复计算子问题，使用记忆化搜索再计算出子问题的结果时保存结果。
*/
int Backpack_mem_search(int i, int j) // 前i个物品，放进容量为j的背包
{
  if (dp[i][j])
    return dp[i][j];
  if (i == 0)
    return 0;
  if (c[i] > j)
    dp[i][j] = Backpack_mem_search(i - 1, j);
  else
    dp[i][j] = max(Backpack_mem_search(i - 1, j), Backpack_mem_search(i - 1, j - c[i]) + w[i]);
  return dp[i][j];
}
int Backpack_Main()
{
  int n, C;
  scanf("%d %d", &n, &C);
  for (int i = 1; i < n; i++)
    scanf("%d %d", &c[i], &w[i]);
  printf("%d", Backpack_recursion(n, C));
  printf("%d", Backpack_mem_search(n, C));
  return 0;
}

// 滚动数组
/*
DP的状态方程常常是二维和二维以上的，会占用很多空间。
滚动数组可以大大减少占用空间，能将二维状态方程的空间复杂度O(N^2)优化到O(N)，更高维的也可以优化减少一维
例如从0/1背包问题的状态转移方程dp[i][j]=max(dp[i-1][j],dp[i-1][j-c[i]]+w[i]);中可以看出，
dp[i][j]只与dp[i-1][]有关，与前面的dp[i-2][]，dp[i-3][]等都没有关系。
从前面的图表中也可以看出，每一行是根据上一行推算出来的，与更前面的行没有关系。
那些用过的、已经无用的dp[i-2][]、dp[i-3][]等就变得多余了，所以可以复用这些空间，
用新的一行覆盖已经无用的一行(滚动)，这样只需要两行就够了

滚动数组的两种实现方法：交替滚动和自我滚动

滚动数组的缺点：覆盖了中间转移状态，只留下了最后的状态，因此舍弃了很多信息，
               导致无法回溯，不能输出具体的方案。
*/

//(1)交替滚动
/*
定义dp[2][]，用dp[0][]和dp[1][]交替滚动。这种方法的优点是逻辑清晰不易出错。
下面的代码中，now始终指向正在计算的最新的一行，old指向已经计算过的旧的一行，
按照原递推代码，now相当于i，old相当于i-1。
*/
int alternant_scroll_dp[2][N]; // 用滚动数组替换原来的二维dp[][]
int Backpack_alternant_scroll_array(int n, int C)
{
  int now = 0, old = 1; // now指向当前正在计算的一行，old指向旧的一行
  for (int i = 1; i <= n; i++)
  {
    swap(old, now); // 交替滚动，now始终指向最新的一行
    for (int j = 0; j <= C; j++)
    {
      if (c[i] > j)
        alternant_scroll_dp[now][j] = alternant_scroll_dp[old][j];
      else
        alternant_scroll_dp[now][j] = max(alternant_scroll_dp[old][j], alternant_scroll_dp[old][j - c[i]] + w[i]);
    }
  }
  return dp[now][C];
}

//(2)自我滚动
/*
用两行交替滚动数组是很符合逻辑的做法，但还可以继续精简，用一个一维的dp[]就够了。
即让数组实现自我滚动。
经过自我滚动数组的优化，以0/1背包为例，空间复杂度可以从O(NC)降低到O(C)。
*/

/*
状态定义：int own_scroll_dp[N];  own_scroll_dp[j]表示背包容量为j时的最大价值
状态转移方程：
第一个for循环遍历每个物品，第二个for循环遍历背包容量，for循环内的语句分为两种情况：
如果不装第i个物品，仍然有own_scroll_dp[j]=own_scroll_dp[j],如果装了第i个物品，
那么背包的价值为own_scroll_dp[j-c[i]]+w[i]
其中，最关键的部分时第二个for循环，j是反过来循环的，即从后面往前面覆盖。
j不可以从小到大循环，由于滚动数组重复使用同一个空间，会得到错误答案。
j应该从大到小循环，这样先计算最后的dp[j]，它不影响前面的状态。
*/
int own_scroll_dp[N];
int Backpack_own_scroll_array(int n, int C)
{
  for (int i = 1; i <= n; i++)
    for (int j = C; j >= c[i]; j--) // 反过来循环
      own_scroll_dp[j] = max(own_scroll_dp[j], own_scroll_dp[j - c[i]] + w[i]);
  return own_scroll_dp[C];
}

// 二、线性DP
/*
例1：装箱问题(0/1背包问题简化版)
有一个箱子，其容量为V(正整数，0<=V<=2e4)，同时有n个物品(0<n<=30)，
每个物品有一个体积(正整数)。要求从n个物品中，任取若干个装入箱内，使箱子的剩余空间最小。
输入：第一行一个整数V，表示箱子容量。第二行一个整数n，表示有n个物品
      接下来n行，分别表示这n个物品的各自体积。
输出：一个数，表示箱子的最小剩余空间。
本题为0/1背包问题的简化版，不用考虑物品的价值。
*/
const int N2 = 2e4 + 10;
int dp1[2][N2]; // 滚动数组实现
int v[35];
void packing()
{
  int n, V;
  scanf("%d", &V);
  scanf("%d", &n);
  for (int i = 1; i <= n; i++)
    scanf("%d", &v[i]);
  int old = 1, now = 0;
  for (int i = 1; i <= n; i++)
  {
    swap(old, now);
    for (int j = 0; j <= V; j++)
    {
      if (v[i] > j)
        dp1[now][j] = dp1[old][j];
      else
        dp1[now][j] = max(dp1[old][j], dp1[old][j - v[i]]);
    }
  }
  printf("%d", V - dp[now][V]);
  return;
}

/*
例2：2022(解决0/1背包问题的方案数)
(填空题)将2022拆分成10个互不相同的正整数，总共有多少种拆分方法？注意交换顺序视为同一种方法。

本题为0/1背包问题的扩展，求最优的方案一共有多少种。
题目求10个正整数的组合情况，这10个正整数相加等于2022。
这一题可以看作0/1背包问题：背包容量为2022，物品体积为1~2022，往背包中装10个物品，
要求总体积为2022，问一共有多少种方案。与标准0/1背包问题的区别是这一题为求方案总数。
定义dp[][][],dp[i][j][k]表示从数字1~i取j个和为k的方案数。
下面的分析沿用标准0/1背包问题的分析方法。从i-1扩展到i，分为以下两种情况：
(1)k>=i 数i可以要，也可以不要。
如果要：从1到i-1取j-1个数，再取i，等价于dp[i-1][j-1][k-i];
如果不要：从1到i-1中取j个数，等价于dp[i-1][j][k]
合起来：dp[i][j][k]=dp[i-1][j][k]+dp[i-1][j-1][k-i];
(2)k<i  数i比总和k还大，显然i不能用，有dp[i][j][k]=dp[i-1][j][k]。
*/
long long dp2[2300][11][2022];
int Backpack_2022()
{
  for (int i = 0; i < 2; i++)
    dp2[i][0][0] = 1; // 必须要进行初始化 并且这样是符合逻辑的 否则怎么加都是0
  int now = 0, old = 1;
  for (int i = 1; i <= 2022; i++)
  {
    swap(old, now);
    for (int j = 1; j <= 10; j++) // j可以从小到大，也可以从大到小。
      for (int k = 1; k <= 2022; k++)
        if (k < i) // 无法装进背包
          dp2[now][j][k] = dp2[old][j][k];
        else
          dp2[now][j][k] = dp2[old][j][k] + dp2[old][j - 1][k - i];
  }
  printf("%lld", dp2[now][10][2022]);
  return 0;
}

/*
例3：完全背包
小明有一个容量为C的背包。这天他去商场购物，商场一共有N种物品，第i种物品的体积为c[i]，价值为w[i]，
每种物品有无限多个。小明想知道在购买的物品总体积不超过C的情况下，能获得的最大价值是多少？
输入：第一行两个正整数N、C，分别表示物品总数和背包容量。
      接下来N行每行两个正整数c、w，分别表示物品的体积和价值。
      1<=N<=1e3,1<=C<=1e3,1<=c[i],w[i]<=1e3。
输出：一个整数 表示获得的最大价值

本题与0/1背包问题相似，但是完全背包的物品是无限的，每种物品都可以装0、1、2、···、C/c[i]个
所以额外考虑的问题就是：每种物品需要拿几个，我们只需要在考虑0/1背包问题的代码上加入重复拿一个物品的过程即可。
*/
int dp3[N][N]; // dp[i][j]表示第1~i个物品装进容量为j的背包获得的最大价值，与0/1背包类似。
int w3[N], c3[N];
int Complete_Backpack()
{
  int n, C;
  scanf("%d %d", &n, &C);
  for (int i = 1; i <= n; i++)
    scanf("%d %d", &c[i], &w[i]);
  for (int i = 1; i <= n; i++)
  {
    for (int j = 1; j <= C; j++)
    {
      if (c[i] > j)
        dp3[i][j] = dp3[i - 1][j];
      else
        dp3[i][j] = max(dp3[i - 1][j], dp[i][j - c[i]] + w[i]);
      /*
      重复拿一个物品的过程，如果这个物品不再拿了，就继承dp[i-1][j](上一个物品拿了多少个是已经确定了的)的最大价值
      如果这个物品还可以继续拿，就继续，直到拿不了为止，在这个过程中取最大值即得到最优解。
      */
    }
  }
  printf("%d", dp3[n][C]);
  return 0;
}
/*
完全背包由于一个物品可以拿多次，所以用自我滚动数组优化时可以从前往后枚举
只需将上述代码中两个for循环内的判断部分改为dp[j]=max(dp[j],dp[j-c[i]]+w[i]);即可。
*/

/*
例4:最长公共子序列
给定一个长度为n的数组A和一个长度为m的数组B。请求出它们的最长公共子序列长度为多少。
输入：第一行两个整数n,m。第二行n个整数a[i]，第三行m个整数b[i](1<=n,m<=1e3, 1<=a[i],b[i]<=1e9)
输出：一个整数，表示答案。

注意：子序列和字符串的子串是不同的概念，子序列是指在给定序列中删除若干元素得到的序列，可以不连续，而字串是连续的。
比如X={A,B,C,B,D,A,B}，子序列有{A,B,C,B,A},{A,B,D},{B,C,D,B}等。

用dp[i][j]表示序列A的前i个元素组成的序列和B的前j个元素组成的序列 的最长公共子序列的长度，那么dp[n][m]即为答案。
状态转移方程的推导：
解分为两种情况
(1)当a[i]=b[j]时，已经求得A[i-1]和B[j-1]的最长公共子序列，在其尾部加上a[i]或b[j]即可得到更长的公共子序列。
因此，dp[i][j]=dp[i-1][j-1]+1;
(2)当a[i]!=b[j]时，需要求解两个子问题：A[i-1]和B[j]的最长公共子序列   A[i]和B[j-1]的最长公共子序列。
取其中的最大值。因此，dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
DP解决的时间复杂度为O(nm)。
*/
const int SIZE = 1e3 + 10;
int A[SIZE], B[SIZE];
int dp_LCS[SIZE][SIZE];
int Longest_common_subsequence()
{
  int n, m;
  scanf("%d %d", &n, &m);
  for (int i = 1; i <= n; i++)
    scanf("%d", &A[i]);
  for (int i = 1; i <= m; i++)
    scanf("%d", &B[i]);
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      if (A[i] == B[j])
        dp_LCS[i][j] = dp_LCS[i - 1][j - 1] + 1;
      else
        dp_LCS[i][j] = max(dp_LCS[i - 1][j], dp_LCS[i][j - 1]);
  printf("%d", dp[n][m]);
}