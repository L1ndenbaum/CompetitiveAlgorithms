#include "../../Heads/Head.h"
// 快速幂

/*
幂运算a^n当n很大时，如果一个一个数地乘，时间复杂度是O(n)，此时可以用快速幂在O(logn)的时间内算出来。
快速幂的一个解法是分治法，即先算a^2，再算(a^2)^2，以此类推，直到算到a^n。但标准快速幂是用位运算实现的。
基于位运算的快速幂用到了倍增的原理，以a^11为例说明如何用倍增法做快速幂运算。
(1)幂次与二进制的关系:
将a^11分解为a^8、a^2、a^1的乘积：a^11=a^(8+2+1)=a^8 * a^2 * a^1。
其中a^1、a^2、a^8的幂次都是2的倍数，所有的幂a^i都是倍乘关系，可以逐级递推，在代码中使用a*=a实现。
(2)幂次用二进制分解:
将11分解为8+2+1，只需将n按照二进制数处理即可。
n=11(十进制)=1011(二进制)=2^3+2^1+2^0=8+2+1。
(3)利用二进制的位运算跳过那些没有的幂次，比如1011需要跳过a^4:
[1]n&1，取n的最后一位，并且判断这一位是否需要跳过。
[2]n>>=1，将n右移一位，目的是将刚处理过的n的最后一位丢掉。
*/
ll FastPow(ll a, ll n, ll k) // 计算a^n % k的值(幂运算的将结果很大，一般会先取模再输出。根据取模的性质有:(a^n)%m=((a%m)^n)%m)
{
    if (n == 0)
        if (k == 1 || k == -1)
            return 0;
        else
            return 1;
    ll res = 1; // 用res返回结果
    a %= k;     // 防止下面的res*a越界
    while (n)   // 将n看成二进制数，逐个处理它的最后一位。
    {
        if (n & 1) // 如果n的最后一位是1，则表示这个地方需要参与计算。
            res = (res * a) % k;
        a = (a * a) % k; // 递推：a^2 --> a^4 --> a^8 --> a^16
        n >>= 1;         // n右移一位，将刚处理过的n的最后一位丢弃掉。
    }
    return res;
}