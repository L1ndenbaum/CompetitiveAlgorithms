// 一、模运算
/*
模运算是大数运算中的常用操作。如果一个数太大，无法直接输出，或者不需要直接输出，可以对其取模后，缩小数值再输出。
取模运算 a%b 一般要求a和b的正负号一致。
取模操作的加、减、乘满足分配律，注意仍要求a+b、a-b、a*b为正数，如果有负数需要小心处理。
(a+b)%m=((a%m)+(b%m))%m
(a-b)%m=((a%m)-(b%m))%m
(a*b)%m=((a%m)*(b%m))%m   有三个或以上数时同理   先乘后取模等于先取模后乘再取模
(a^n)%m=((a%m)^n)%m
注意：除法没有这种性质！
*/

/*
例:取模降低时间复杂度
小明决定从下周一开始，周一到周五每天做a道题目，周六周日每天做b道题目，请计算小明将在第几天实现做题数大于等于n题
输入：一行 三个整数 a,b,n(1<=a,b,n<=1e18)
输出：一个数 表示在第几天做题数大于等于n

本题由于数据范围n最大值有1e18，不能用模拟法(时间复杂度O(n))进行，会超时，利用取模计算可以将复杂度降低到O(1)
*/
#include <iostream>
using namespace std;
using ll = long long;
int Mod()
{
    ll a, b, n;
    cin >> a >> b >> n;
    ll problem_a_week = a * 5 + b * 2;  // 每周做的题
    ll days = (n / problem_a_week) * 7; // 一共需要的天数
    n %= problem_a_week;                // 做了k整周后还剩下的题目数
    // 之后计算最后一周内要几天能做完
    if (n <= a * 5) // 如果剩下的所有的题在5天内可以做完
    {
        days += n / a + (n % a ? 1 : 0); // 如果正好做完，就不用加1，否则加1
    }
    else // 剩下的所有题目5天内做不完 要用到周六周日
    {
        days += 5, n -= a * 5;
        days += n / b + (n % b ? 1 : 0); // 如果正好做完，就不用加1，否则加1
    }
    cout << days;
    return 0;
}

// 二、快速幂与快速乘法
/*
1.快速幂
幂运算a^n当n很大时，如果一个一个数地乘，时间复杂度是O(n)，此时可以用快速幂在O(logn)的时间内算出来。
快速幂的一个解法是分治法，即先算a^2，再算(a^2)^2，以此类推，直到算到a^n。但标准快速幂是用位运算实现的。
基于位运算的快速幂用到了倍增的原理，以a^11为例说明如何用倍增法做快速幂运算。
(1)幂次与二进制的关系:
将a^11分解为a^8、a^2、a^1的乘积：a^11=a^(8+2+1)=a^8 * a^2 * a^1。
其中a^1、a^2、a^8的幂次都是2的倍数，所有的幂a^i都是倍乘关系，可以逐级递推，在代码中使用a*=a实现。
(2)幂次用二进制分解:
将11分解为8+2+1，只需将n按照二进制数处理即可。
n=11(十进制)=1011(二进制)=2^3+2^1+2^0=8+2+1。
(3)利用二进制的位运算跳过那些没有的幂次，比如1011需要跳过a^4:
[1]n&1，取n的最后一位，并且判断这一位是否需要跳过。
[2]n>>=1，将n右移一位，目的是将刚处理过的n的最后一位丢掉。
*/
ll FastPow(ll a, ll n, ll k) // 计算a^n % k的值(幂运算的将结果很大，一般会先取模再输出。根据取模的性质有:(a^n)%m=((a%m)^n)%m)
{
    if (n == 0)
    {
        if (k == 1 || k == -1)
            return 0;
        else
            return 1;
    }
    ll res = 1; // 用res返回结果
    a %= k;     // 防止下面的res*a越界
    while (n)   // 将n看成二进制数，逐个处理它的最后一位。
    {
        if (n & 1) // 如果n的最后一位是1，则表示这个地方需要参与计算。
            res = (res * a) % k;
        a = a * a % k; // 递推：a^2 --> a^4 --> a^8 --> a^16
        n >>= 1;       // n右移一位，将刚处理过的n的最后一位丢弃掉。
    }
    return res;
}

/*
2.快速乘法
快速乘法计算a*b%m的原理是将b分解为二进制。 b=Sigma(b[i]*(2^i))
b[i]是二进制中b的每一位，不是0就是1 将b的每一位和权重乘积进行加和得到的就是十进制的b.
之后，a*b=a*(Sigma(b[i]*(2^i)))=Sigma(a*b[i]*2^i)
在代码中，如果b的最后一位是1，那么就处理这一位，将res加上a*b在这一位的权重
*/
ll Plus(ll a, ll b, ll m) // 计算a*b%m
{
    ll res = 0;
    while (b)
    {
        if (b & 1)               // 当b的最后一位是0，就加到res上
            res = (res + a) % m; // 这里取模利用加法取模的性质(a+b)%m=((a%m)+(b%m))%m
        a = (a << 1) % m;        // 通过每次将a乘2实现2^i中i逐渐增加的操作。
        b >>= 1;                 // 处理完b的最后一位后将其舍弃，直至b为0
    }
    return res;
}
// 三、GCD和LCM
/*
1.最大公约数GCD
(1)定义：
整数a和b的最大公约数是指能同时整除a和b的最大整数，即为gcd(a,b)。
由于-a的因子和a的因子相同，因此gcd(a,b)=gcd(|a|,|b|)。编程时只需要关注正整数的最大公约数。
(2)性质：
[1]gcd(a,b)=gcd(a,a+b)=gcd(a,k*a+b)   gcd(a,b-a)=gcd(a,b)
[2]gcd(ka,kb)=k*gcd(a,b)
[3]多个整数的最大公约数gcd(a,b,c)=gcd(gcd(a,b),c)
[4]若gcd(a,b)=d，则gcd(a/d,b/d)=1，则a/d与b/d互素  (重要定理)
[5]gcd(a+c*b,b)=gcd(a,b)
(3)编程实现：
[1]内置函数：
C++内置了求最大公约数的函数__gcd(a,b) 定义在<algorithm>头文件中，如果参数中有负数，这个函数可能会返回负数
[2]手写gcd()函数：
使用欧几里得算法，用辗转相除法求gcd，即gcd(a,b)=gcd(b,a%b)。设a>b，辗转相除法的时间复杂度为O(3*log(2a))
*/

// 辗转相除法求gcd
int GCD(int a, int b)
{
    return b ? GCD(b, a % b) : a;
}

/*
2.最小公倍数LCM
a与b的最小公倍数LCM(a,b)可以通过基本算术定理得到
基本算术定理：任何大于1的正整数n都可以唯一分解为有限个素数的乘积
(1)性质：
[1]LCM(a,b)=a*b/GCD(a,b)
[2]多个数的最小公倍数LCM(a,b,c)=LCM(LCM(a,b),c)
[3]若i是x的因数，并且i是y的因数，那么i是LCM(x,y)的因数
*/