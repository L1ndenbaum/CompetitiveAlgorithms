/*树是非线性数据结构，能够很好地描述数据的层次关系。二叉树是最常用的树形结构，常常将一般的树转换为二叉树处理*/

// 一.二叉树
/*
1.定义：二叉树的每个节点最多有两个子节点，称左孩子，右孩子，以他们为根的子树成为左、右子树
      1号节点为二叉树的根，从根到节点u的路径长度为u的深度，
      u到它的叶子节点的最大路径长度定义为u的高度，
      根的高度最大，成为树的高。

2.性质：
(1)二叉树的每层节点数以2的倍数递增，第i层最多有2^(i-1)个节点，
(2)若每层的节点数都是满的，称为满二叉树。一个n层的满二叉树共有2^n-1个节点，
   如果满二叉树只在最后一层有缺失，并且缺失的编号都在最后，称为完全二叉树


3.二叉树的优点：
(1)满二叉树访问效率高(不满的二叉树，特别是极端的像一条链一样的二叉树访问效率会降低，维护二叉树平衡时高级数据结构的主要任务之一)
(2)二叉树适合做从整体到局部、局部到整体的操作。二叉树内的一颗子树可以看作整棵树的子区间，
   求区间最值、区间和、区间翻转、区间合并、区间分裂等用二叉树很快
(3)基于二叉树的算法易设计和实现。二叉树用BFS、DFS处理很简便
*/

/*
4.二叉树的存储结构
二叉树的一个节点的存储，包括节点的值、左右子节点，有动态、静态两种存储方法
*/

//(1)动态二叉树。数据结构中一般这样定义二叉树
struct static_node
{
    int value; // 节点的值，可以定义多个值
    static_node *l_son, *right_son;
};
/*
动态新建一个Node时，用new动态申请一个节点。使用完毕后用delete释放。
动态二叉树不浪费空间，但需要管理
*/

//(2)静态二叉树。竞赛中使用静态数组实现二叉树
// 编码一般不用tree[0],0用来表示节点，若一个叶子节点tree[i]没有子节点，则它的l_son=r_son=0
/*
一颗节点总数为k的完全二叉树，设1号节点为根节点，有以下性质：
编号i>1的节点，其父节点为i/2
如果节点i有孩子，那么它的左孩子是节点2*i,右孩子是节点2*i+1
若2*i>k,那么节点i没有孩子；如果2*i+1>k,那么节点i没有右孩子
*/
const int N = 1e5;
struct node
{
    int value;
    int l_son, r_son;
} tree[N];

/*
5.多叉树转化为二叉树
多叉树有B-树，B+树等。将多叉树转化为二叉树的应用场景不多见，简单方法为：
将第一个孩子作为左孩子，将其兄弟节点作为右孩子，这样做的缺点是可能导致树退化为一条长链
*/

/*
6.二叉树的遍历：
(1)宽度优先遍历：按一层层从上到下的顺序，从左到右访问，使用BFS 队列实现
(2)深度优先遍历：
DFS遍历二叉树是对父节点、左孩子、右孩子进行组合，有先序遍历、中序遍历、后序遍历(序均指父序)三种访问顺序，默认左孩子在右孩子前面
先序遍历：按父节点、左孩子、右孩子的顺序访问

中序遍历：按左孩子、父节点、右孩子的顺序访问，
在二叉搜索树中，中序遍历实现了排序功能，返回结果是一个有序排列。
中序遍历还有一个重要特征：如果已知根节点，那么在中序遍历的结果中，排在根节点左边的点都在左子树上，右边的点都在右子树上

后序遍历：按左孩子、有孩子、父节点的顺序访问。 其特点为最后一个节点为根，对任意子树也成立

三种遍历的关系：
已知某棵二叉树的中序遍历和另一种遍历，可以把这棵树构造出来
如果不知道中序遍历，只有先序遍历+后序遍历，则不能确定一棵二叉树
*/

// 二、哈夫曼树和哈夫曼编码
/*哈夫曼树是一类带权路径长度最短的最优树，是贪心思想在二叉树上的应用，哈夫曼树的经典应用为哈夫曼编码*/

/*
1.哈夫曼树：
(1)二叉树上两个节点之间的路径长度指这条路径经过的边的数量。树的路径长度是从根到每个节点的路径长度之和。
   二叉树越平衡，从根到其他节点的路径越短，树的路径长度也越短。完全二叉树的路径长度最短
(2)到带权节点的推广：从根到一个带权节点的带权路径长度，是从根到该节点的路径长度与节点权值的成绩。
   树的带权路径长度是所有叶子节点的带权路径长度之和。
   由于节点有权值，那么一棵平衡的二叉树并不一定有最小的带权路径长度。
(3)给定n个权值，构造一棵有n个叶子节点的二叉树，每个叶子节点对应一个权值。有多种构造方法，
   将其中带权路径长度最小的二叉树成为哈夫曼树，或最优二叉树。
(4)构造哈夫曼树的方法：将权值大的节点放在离根节点近的层次，权值小的节点放在离根节点远的层次上，如下：
   将每个权值构造成一棵只有一个节点的树，n个权值构成了n棵树，记为集合F{T[1],T[2],···,T[n]}
   在F中选择权值最小的两棵树T[i]和T[j]，合并为一棵新的二叉树T[x]，其权值等于T[i]+T[j]，左右子树为T[i]、T[j]
   在F中删除T[i]和T[j]，并将T[x]加入F
   重复上述步骤，直到F中只含有一棵树，即为哈夫曼树

2.哈夫曼编码：哈夫曼树的经典应用，是一种“前缀”最优编码
*/

/*
场景:输入一个字符串，分别用普通ASCII编码(每个字符8b)和哈夫曼编码，输出编码前后的长度和压缩比
     输入多组数据，输入END时停止
*/
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
// int main()
// {
//     string s;
//     priority_queue<int, vector<int>, greater<int>> q;
//     while (getline(cin, s) && s != "END")
//     {
//         sort(s.begin(), s.end());
//         int num = 1; // 一种字符出现的次数
//         for (int i = 1; i <= s.size(); i++)
//         {
//             if (s[i] != s[i - 1])
//             {
//                 q.push(num);
//                 num = 1;
//             }
//             else
//             {
//                 num++;
//             }
//         }
//         int ans = 0;
//         if (q.size() == 1) // 如果只有一种字符
//         {
//             ans = s.size();
//         }
//         while (q.size() > 1) // 最后一次合并不用加到ans中
//         {
//             int a = q.top();
//             q.pop();
//             int b = q.top();
//             q.pop();        // 取出频次最少的两个
//             q.push(a + b);  // 合并为新节点，重新放进队列
//             ans += (a + b); // 一种字符进入几次队列，就累加几次
//             // 入一次队列，表示它在二叉树上深了一层，编码长度加1
//         }
//         q.pop();
//         cout << s.size() * 8 << ' ' << ans << ' ' << (double)(s.size() * 8 / (double)ans) << endl;
//     }
// }