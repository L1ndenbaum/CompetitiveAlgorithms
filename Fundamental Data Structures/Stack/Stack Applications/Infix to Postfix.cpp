#include "../../../Heads/Head.h"
/*
中缀表达式转后缀表达式
[1]从左到右扫描中缀表达式的每个字符。
[2]如果遇到一个操作数（数字或字母），则直接输出到后缀表达式。
[3]如果遇到一个左括号，则将其压入栈中。
[4]如果遇到一个右括号，则依次弹出栈中的运算符并输出到后缀表达式，直到遇到一个左括号，然后将左括号弹出栈（不输出）。
[5]如果遇到一个运算符，例如+，−，×，÷等，则比较它和栈顶的运算符的优先级：
    (1)如果栈为空，或者栈顶是左括号，或者当前运算符的优先级高于栈顶的运算符，则将当前运算符压入栈中。
    (2)如果当前运算符的优先级低于或等于栈顶的运算符，则依次弹出栈中的运算符并输出到后缀表达式，直到满足上述条件，然后将当前运算符压入栈中。
[6]重复步骤1-5，直到扫描完整个中缀表达式。
[7]最后，将栈中剩余的运算符依次弹出并输出到后缀表达式。

后缀表达式的计算方法：
遇到数字就进栈,遇到操作符就将栈顶的两个数出栈进行计算,再将结果入栈,直到表达式结束。
*/

int Precedence(char c) // 返回一个运算符的优先级
{
    if (c == '^')
        return 3;
    else if (c == '/' || c == '*')
        return 2;
    else if (c == '+' || c == '-')
        return 1;
    else
        return -1;
}
char associativity(char c) // 返回一个运算符的结合性(左结合或右结合)
{
    if (c == '^') // 乘方符号是右结合的
        return 'R';
    return 'L'; // 其他运算符都是左结合的
}
void Infix2Postfix(string s)
{
    stack<char> st; // 储存运算符的栈
    string result;
    for (auto c : s) // 从头到尾扫描字符串
    {
        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) // 如果一个字符是操作数，就添加到结果中
            result += c;
        else if (c == '(') // 如果一个字符是左括号，入栈
            st.push('(');
        else if (c == ')') // 如果是右括号，直到遇到左括号前，全部弹出并添加到结果中
        {
            while (st.top() != '(')
            {
                result += st.top();
                st.pop();
            }
            st.pop(); // 弹出左括号
        }
        else // 如果是运算符
        {
            while (!st.empty() && Precedence(c) < Precedence(st.top()) ||
                   !st.empty() && Precedence(c) == Precedence(st.top()) &&
                       associativity(c) == 'L')
            {
                /*
                当此运算符是左结合的时:
                若栈顶的符号优先级 >= 此运算符,那么就一直弹出栈到结果中
                */
                result += st.top();
                st.pop();
            }
            st.push(c); // 如果栈为空 或者栈顶的优先级小于此运算符,直接将这个运算符入栈
        }
    }
    while (!st.empty()) // 最后将所有栈中元素弹出到结果中
    {
        result += st.top();
        st.pop();
    }
    cout << result << endl;
}