#include <iostream>
#include <queue>
#include <deque>
using namespace std;
#define N 1005
/*队列的数据存取方式为先进先出，只能向队尾插入数据，从队头移除数据。
  队列有两种实现方式：链队列 循环队列
  链队列是单链表的一种特殊情况，用指针把各个节点连接起来
  循环队列是一种顺序表，使用一组连续的存储单元依次存放队列元素，
  用两个指针head和tail表示对头元素和队尾元素，当head和tail走到底，下一步回到开始的位置，
  从而在这组连续空间内循环。 循环队列可以解决溢出问题，若不循环，head与tail都会一直往前走，可能会溢出*/
// 队列、栈的缺点都是查找很慢，需要从头到尾找，某些情况下可以使用优先队列，让优先级最高的元素先出队列

// 1.STL queue
/*STL的queue主要支持push(item)、返回队尾、队首元素、删除队首元素、返回size、检查队列是否为空*/

/*场景：内存中有M个单元，每个单元能储存一个单词和意译。当一个新单词存入内存前，若当前内存中已存入的单词
  数量不超过M-1，则新单词会存入一个未使用的内存单元，若已经存入M个单词，则清空最早进入的单词，腾出单元存放新单词
  现在有一篇长N个单词的英语文章，给定这个待翻译的文章，翻译软件需要去外存查找多少次词典？假设翻译开始前内存中没有任何单词
  输入两行，第一行M和N，代表内存容量和文章长度，第二行N个非负整数，大小不超过1000，一个数代表一个单词，同一个数则代表同一个单词*/
int Hash[1005] = {0}; // 这里使用哈希检查内存中有没有单词,Hash[i]=1表示单词i在内存中
queue<int> mem;       // 队列模拟内存
void STL_queue(int m, int n)
{
  int count = 0; // 查词典的次数
  while (n--)
  {
    int en;
    cin >> en;
    if (!Hash[en]) // 如果该单词不在词典中
    {
      count++;
      mem.push(en); // 该单词进入内存
      Hash[en] = 1;
      if (mem.size() > m) // 内存中去掉单词
      {
        Hash[mem.front()] = 0;
        mem.pop();
      }
    }
  }
  cout << count << endl;
}
