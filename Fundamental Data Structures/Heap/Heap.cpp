/*
堆：
堆是一种树形结构，树的根堆顶，堆顶始终保持为所有元素的最优值。有最大堆与最小堆。
最大堆的根节点是最大值，最小堆的根节点是最小值。这里都以最小值为例
堆一般使用二叉树实现，称为二叉堆。二叉堆的典型应用有堆排序额优先队列
*/

/*
一、二叉堆的概念
二叉堆是一棵完全二叉树。用数组实现的二叉树堆，树中的每个节点与数组中存放的元素对应。
树的每层，除了最后一层可能不满，其他都是满的。
二叉堆中的每个节点，都是以它为父节点的子树的最小值。
1.用数组arr[]储存完全二叉树，节点数量为n，arr[1]为根节点，有以下性质：
(1)i>1的节点，其父节点位于i/2
(2)如果2*i>n,那么节点i没有孩子；如果2*i+1>n，那么节点i没有右孩子
(3)如果节点i有孩子，那么它的左孩子是2*i,右孩子是2*i+1。

2.堆的操作有进堆和出堆
(1)进堆：每次把元素放进堆，都调整堆的形状，使根节点保持最小
(2)出堆；每次去除的对丁，就是整个堆的最小值，同时调整堆，使新的堆顶最小
进堆和出堆逐层调整，计算复杂度为O(以2为底的n的对数)

二、二叉堆的操作
堆的操作有两种：上浮、下沉
1.上浮：某个节点的优先级上升，或者在堆底加入一个新元素(建堆，把新元素加入堆)，此时需要从下到上恢复堆的顺序
2.下沉：某个节点的优先级下降，或者将根节点替换为一个较小的新元素(弹出堆顶，用其他元素替换它)，
        此时需要从上到下恢复堆的顺序
堆经常用于实现优先队列，上浮对应优先队列的插入操作push()，下沉对应优先队列的删除队头操作pop()

三、手写二叉堆
场景：初始小根堆为空，需要支持以下3种操作：
操作1：输入1 x，表示将x插入堆中
操作2：输入2，输出该小根堆内的最小数
操作3：输入3，删除该小根堆内的最小数
第一行输入一个正整数N表示操作的个数,N<=1e6；接下来N行每行1或2个正整数表示三种操作之一
对于每个操作2，输出一个整数表示答案
*/

#include <iostream>
using namespace std;
const int N = 1e6 + 5;
int heap[N], len = 0; // len用于记录当前节点个数
void push(int x)      // 上浮，插入新元素
{
    heap[++len] = x;
    int i = len;                           // 此时len为当前节点，节点内的数是x
    while (i > 1 && heap[i] < heap[i / 2]) // 当i不指向头节点(i>1) heap[i]为当前节点值，heap[i/2]为父节点值
    {
        // 由于是小根堆，如果当前节点小于父节点，我们就让它上浮，与父节点互换位置
        swap(heap[i], heap[i / 2]);
        i = i / 2; // 互换位置后，当前节点位置用互换之前的父节点位置替换
    }
}
void pop() // 下沉，删除堆头，并调整堆
{
    heap[1] = heap[len--]; // 根节点替换为最后一个节点，节点数量减1
    int i = 1;
    // 当前节点为i 左孩子为2*i 右孩子为2*i+1(如果有孩子)
    while (2 * i <= len) // 至少有左儿子
    {
        int son = 2 * i;                            // 左儿子
        if (son < len && heap[son + 1] < heap[son]) // son<len表示有右儿子，选儿子中较小的那个
        {
            son++;
        }
        if (heap[son] < heap[i])
        {
            swap(heap[son], heap[i]);
            i = son; // 下沉到儿子处
        }
        else
        {
            break; // 如果不比儿子小，就停止下沉
        }
    }
}
void Heap(int n)
{
    while (n--)
    {
        int op;
        scanf("%d", &op);
        switch (op)
        {
        case 1:
            int x;
            scanf("%d", &x);
            push(x); // 进堆
            break;
        case 2:
            printf("%d\n", heap[1]); // 打印堆头
            break;
        default:
            pop(); // 删除堆头
            break;
        }
    }
    return;
}
// int main()
// {
//     int n;
//     scanf("%d", &n);
//     Heap(n);
// }