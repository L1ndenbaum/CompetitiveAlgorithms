#include "../Heads/Head.h"
/*
一、前缀和
    长度为n的数组a[0]到a[n-1],它的前缀和prefix[i]为a[0]到a[i]的和
    前缀和递推:prefix[i]=prefix[i-1]+a[i] prefix[0]空出且为0  时间复杂度O(n)
    计算出前缀和，既可计算a[i]到a[j]的和为sum[j]-sum[i-1]

二、差分
    差分是前缀和逆运算
    差分引用于区间的修改和询问问题。对前缀和数组做差分即可得到原数组 对差分数组做前缀和也可以得到原数组
    把给定的数据集A分为多个区间，对这些区间做多次操作，每次操作是对某个区间内的所有元素作相同的加减操作。
    使用差分数组Diff，当修改某个区间时，只需要修改这个区间的端点，就能记录整个区间的修改，
    对端点的修改非常容易，当所有修改结束后，利用差分数组做前缀和即可计算出修改后的A(只能先修改 再查询)
    例如：对A的[L,R]区间都加上x，差分数组为Diff,只要D[L]+=x,D[R+1]-=x即可。
    A可以是一维线性数组、二维矩阵、三维立体。相应地有一维、二维、三维差分数组。
*/

/*
1.一维差分
    讨论以下场景：
    (1)给定一个长度为n的一维数组a[](下标从1开始，a[0]=0)，数组内每个元素都有初始值
    (2)作m次区间修改，每次修改对区间内所有元素作相同的加减操作。例如：第i次修改，将[L[i],R[i]]内所有元素加上d[i] L[i]、R[i]为第i次修改时的数组区间下标
    (3)询问一个元素的新值是多少
    利用差分操作，可以将时间复杂度降低到O(m+n)
    定义差分数组Diff[i]=a[i]-a[i-1]，则对Diff[i]求和，i从1到k，即为a[k]  即：a[]是Diff[]的前缀和
    对[L,R]内每个元素a[],如果加上x，共分两步：
    先Diff[L]+=x
    之后Diff[R+1]-=x既可
    减法同理

    一维差分的局限性：
    差分数组的区间修改很高效，但单点查询并不高效 在一次查询中，需要计算整个原数组，时间复杂度O(n)
    如果查询不止一次，而是m次修改，k次查询，且修改和查询的顺序是随机的，这样时间复杂度会较高
*/

// 2.二维差分
