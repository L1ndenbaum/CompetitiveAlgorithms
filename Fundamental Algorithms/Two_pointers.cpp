/*
尺取法，又称为双指针，用于解决序列的区间问题，如果区间是单调的，也常用二分法求解
尺取法的操作过程和分治算法步骤相似，有时也用于分治中
*/

/*
一、尺取法的概念
应用场景：
(1)给定一个序列，有时需要它是有序的，先排序
(2)问题和序列的区间有关，且需要操作两个变量，可以用两个下标i,j扫描区间
尺取法有两种扫描方向：同向扫描和反向扫描
反向扫描的i和j方向相反，i从头到尾，j从尾到头，在中间相会
同向扫描的i和j方向相同但速度不同，都是从头到尾，一个指针会跑在前面
将同向扫描的i、j指针称为快慢指针，把反向扫描的i、j成为左右指针。
快慢指针在序列上产生了一个大小可变的滑动窗口，可以应用于寻找区间、数组去重、多指针等问题
*/

// 二、反向扫描
// 下面反向扫描的应用与编码
/*
场景：找指定和的整数对
输入n(n<=1e5)个整数在数组a[]中。找出其中两个数使他们的和等于m,整数均为int类型，第一行输入a[],第二行输入m
打印所有可能的答案

定义反向指针i,j。i从0起，j从n-1起，先对数组排序，之后i,j靠拢，如果a[i]+a[j]的值<m,i右移，若a[i]+a[j]>m,j左移
直到找到指定的值。排序的时间复杂度尾O(n*log(n)),检查的复杂度为O(n)总复杂度为O(nlog(n))
*/
#include <iostream>
#include <algorithm>
using namespace std;
void Find_sum(int *a, int n, int m)
{
    sort(a, a + n);
    int i = 0, j = n - 1;
    while (i < j)
    {
        int sum = a[i] + a[j];
        if (sum > m)
        {
            j--;
        }
        else if (sum < m)
        {
            i++;
        }
        else
        {
            cout << a[i] << ' ' << a[j] << endl;
            i++; // 输出多种情况
        }
    }
}

// 三、同向扫描
/*
场景1：寻找区间和   这是用尺取法产生滑动窗口的典例
给定一个长度为n的数组a[]和一个数s，在这个数组中找一个区间，使这个区间的数组元素之和等于s。输出区间的起点和终点位置
输入：第一行输入n 第二行输入a[]的n个数 第三行输入区间和s  要求输出所有可能的情况

方法：定义双指针i,j。初始值i=0,j=0且i<=j。定义sum为区间[i,j]内的元素和，初始值sum=a[0];
     如果sum=s，那么输出一个解。继续，将sum减去元素a[i]并把i向后移动一位
     如果sum>s，那么sum减去元素a[i]并把i向后移动一位(这就表示窗口过大，那么就缩小窗口)
     如果sum<s，那么把j向后移动一位，并把sum的值加上这个新元素(这就表示窗口过小，那么就扩大窗口)
在这个方法中，滑动窗口就是区间[i,j],随着i,j从头到尾移动，窗口滑动扫描了整个序列，检索所有数据
由于i,j不同步进行，窗口大小会改变
计算区间和时，利用sum在每次移动i或j时，只需将sum加减一次，即可得到区间和，复杂度为O(1)

这样的例子还有：给定序列和一个整数M，在序列中找M个连续递增的元素，使它们的区间和最大
               给定一个序列和一个整数K，求一个最短的连续子序列，其中包含至少K个不同的元素。
*/
void Find_section_sum(int *a, int s, int n)
{
    int i = 0, j = 0, sum = a[0];
    while (j < n)
    {
        if (sum >= s)
        {
            if (sum == s)
            {
                printf("%d %d\n", i, j);
            }
            sum -= a[i];
            i++;
            if (i > j) // 窗口大小为1都找不到这个sum==s 那么就重置sum=a[i]，从i位置(注意i位置已更新)重新开始维护滑动窗口
            {
                sum = a[i];
                j++; // 现在i和j是一个位置了
            }
        }
        if (sum < s)
        {
            j++;
            sum += a[j];
        }
    }
}

/*
场景2：数组去重
给定数组a[]，长度为n，把数组中重复的数去掉

方法：
先把数组排序，这样重复的整数就会挤在一起
定义双指针i,j初始均指向a[0]。i和j从头到尾扫描a[]。i指针走得快，从头到尾遍历数组，
j指针走得慢，它始终指向当前不重复部分的最后一个数，即j用于获得不重复的数
扫描数组，快指针执行i++，若此时a[i]不等于慢指针j指向的a[j]，则j++，并把a[i]复制到慢指针j的当前位置a[j]
i扫描结束后，a[0]到a[j]即为不重复的数
*/
void Remove_the_same(int *a, int n)
{
    int i = 0, j = 0;
    sort(a, a + n);
    while (i < n)
    {
        if (a[i] != a[j])
        {
            j++;
            a[j] = a[i];
        }
        i++;
    }
    for (i = 0; i <= j; i++)
    {
        printf("%d ", a[i]);
    }
}

// 四、多指针
/*有时两个窗口指针不够用，需要更多的指针
场景：找相同数对
给出一串数和一个数字C，要求计算出所有A-B=C的数对的个数(不同位置的数字一样的数对,算不同的数对)
输入两行，第一行两个整数n(1<=n<=2e5)和C；第二行n个整数，作为要求处理的那串数,所有数的绝对值小于2^30
输出一个数，表示这串数中包含的满足A-B=C的数对的个数

方法：使用两个指针j、k表示两个相同数的区间，[j,k)区间内每个数都相同，这个区间可以产生k-j个数对，使用第三个指针i作为
主指针从头到尾遍历n个数；j和k是辅助指针，用于查找数字相同的区间[j,k)
*/
void Find_the_same_pairs(int *a, int n, int c)
{
    // 假设用a[1]存储第一个数,这样方便i,j,k的计算
    sort(a + 1, a + 1 + n);
    long long ans = 0;
    for (int i = 1, j = 1, k = 1; i <= n; i++)
    {
        while (j <= n && a[j] - a[i] < c) // 找到第一个a[j]-a[i]>=c的位置
        {
            j++;
        }
        while (k <= n && a[k] - a[i] <= c) // 找到第一个a[k]-a[i]>c的位置
        {
            k++;
        }
        if (a[j] - a[i] == c && a[k - 1] - a[i] == c && k - 1 >= 1) // 前两个条件使区间存在，最后一个条件限制k=1时的特殊情况
        {
            ans += k - j;
        }
    }
    cout << ans;
    return;
}